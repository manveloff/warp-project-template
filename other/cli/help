#!/bin/bash
##################
##     help     ##
#####################################################################
## Вспомогательный скрипт, содержащий справку по всем командам CLI ##
#####################################################################
: '
 
  1. Если help вызван без опций, показать общую справку
  2. Если help вызван с 1-ым аргументом aliases, показать справку по этой команде
  3. Если help вызван с 1-ым аргументом up, показать справку по этой команде
  4. Если help вызван с 1-ым аргументом down, показать справку по этой команде
  5. Если help вызван с 1-ым аргументом update, показать справку по этой команде

'
#########################################################################

# 1. Если help вызван без опций, показать общую справку
if [ $# == 0 ]; then 

  # Показать краткую справку по команде install
  echo  " "  
  echo  "NAME"
  echo  "     app - Единая точка входа в приложение, без агрументов показывает справку"
  echo  " "
  echo  "SYNOPSIS"
  echo  "     . app <команда>"
  echo  " "  
  echo  "OPTIONS"
  echo  " "
  echo  "DESCTIPTION"
  cat <<'EOF'

  app           | Единая точка входа в приложение, без агрументов показывает справку.

  app up        | Запустить проект с помощью docker-compose
    -h          | Показать справку по команде up
    -c <name>   | Имя группы конфигов, с которыми запускать приложение (dev по умол.)
  
  app down      | Остановить проект с помощью docker-compose
    -h          | Показать справку по команде down  
  
  app update    | Обновить среду и файлы проекта с репчика на GitHub
    -h          | Показать справку по команде update
    -n          | Не запускать проект после обновления
    -c <name>   | Имя группы конфигов, с которыми запускать приложение (dev по умол.)    

  app aliases   | Создать в среде окружении шелла функции-хелперы для работы с приложением
    -h          | Показать справку по команде aliases. 

EOF
fi

# 2. Если help вызван с 1-ым аргументом aliases, показать справку по этой команде
if [ $# != 0 ] && [ $1 == "aliases" ]; then 

  # Показать краткую справку по команде install
  echo  " "  
  echo  "NAME"
  echo  "     aliases - создать в среде окружении шелла функции-хелперы для работы с приложением"
  echo  " "
  echo  "SYNOPSIS"
  echo  "     . app aliases"
  echo  " "  
  echo  "OPTIONS"
  echo  "     -h - показать справку по команде"  
  echo  " "
  echo  "DESCTIPTION"
  cat <<'EOF'

  # Где находятся алиасы
    - Они находятся в файле <проект>/other/cli/aliases
    - Там находятся определения bash-функций.
    - То есть, на самом деле это не алиасы, а bash-функции.
    - Функции, а не алиасы, т.к. первым можно передавать аргументы, а это важно.
    
  # Процесс встраивания алиасов в среду окружения текущего шелла
    - Для встраивания алиасов в текущий шелл надо выполнить исполняемый файл aliases.
    - Но не просто выполнить, а с помощью команды source. Примеры:
    
        source aliases
        . aliases       // встроенная команда . (точка) является синонимом source

    - Таким образом aliases исполняется без создания нового дочернего процесса.
    - И все изменения и определения ф-ий в нём отражаются на среде окружения текущего шелла.
    - Поэтому, после выполнения aliases, все опред-ые ф-ии становятся доступны в шелле.
    
  # Когда производится встраивание алиасов
  
    ▪ При выполнении команды: app up
    ▪ При выполнении команды: app aliases
    ▪ При выполнении файла aliases не через CLI: . aliases
        
  # Для чего нужны алиасы
    - Алиасы выполняют очень важную роль, и просто необходимы для работы с проектом.
    - Здесь должен напомнить, что проект работает на основе технологий Docker.
    - Поэтому, например, нельзя просто зайти в каталог с laravel и выполнить: php artisan.
    - Ведь php у нас работает в контейнере, поэтому обращаться к artisan мы должны так:
      
        docker-compose run nginx php artisan
        
    - Аналогичная ситуация с composer, npm, bower, node, и так далее.
    - Это не слишком-то удобно, не так ли? Тут то нам и помогут алиасы.
    - Чтобы стало понятнее, вот несколько примеров таких алиасов:
    
        alias node='function f(){   docker-compose run node node "$@";  };f'
        alias npm='function f(){   docker-compose run node npm "$@";  };f'
        alias gulp='function f(){   docker-compose run node gulp "$@";  };f'
        alias bower='function f(){   docker-compose run node bower --allow-root "$@" ;  };f'
        alias php='function f(){   docker-compose run nginx php "$@";  };f'
        alias artisan='function f(){   docker-compose run nginx php artisan "$@"; };f'
        alias composer='function f(){   docker-compose run nginx composer "$@"; };f'    
   
  # В другом шелле алиасы проекта не существуют
    - Назначение алиасов проекта действуют только в текущем процессе шелла.
    - Представим, ты подключился к серверу по ssh и выполнил . app up в каталоге проекта.
    - Проект запустился, алиасы в текущем работающем процессе шелла создались.
    - Но они будут доступны лишь в этом шелле, но не в любых других шеллах.
    - Но если ты, например:
    
      ▪ Переподключишься к серверу.
      ▪ Подключишься к серверу через ещё одно ssh-подключение.
    
    - То в новых соединениях алиасов уже не будет.
    - Потому что это уже новые шелл-процессы, с новыми окружениями.
    - И в этих окружения определения функций из aliases уже отсутствуют.
    - Чтобы они там появились, можно выполнить: . app aliases.

EOF
fi

# 3. Если help вызван с 1-ым аргументом up, показать справку по этой команде
if [ $# != 0 ] && [ $1 == "up" ]; then 

  # Показать краткую справку по команде install
  echo  " "  
  echo  "NAME"
  echo  "     up - запустить проект с помощью docker-compose"
  echo  " "
  echo  "SYNOPSIS"
  echo  "     . app up"
  echo  " "  
  echo  "OPTIONS"
  echo  "     -h - показать справку по команде"  
  echo  "     -c <name> - имя группы конфигов, с которыми запускать приложение (dev по умол.)"
  echo  " "
  echo  "DESCTIPTION"
  cat <<'EOF'

  # Что имеется в виду под запуском приложения
    - Как уже упоминалось, инфраструктура (php, mysql, и т.д.) идёт в комплекте с проектом.
    - Это стало возможно благодаря технологиям контейнерезации, и Docker в нашем случае.
    - Когда ты запускаешь такое приложение, то происходит примерно следующее:
    
      • Считывается конфиг docker-compose.yml.
      • Запускаются и настраиваются описанные в нём контейнеры.
        - Совокупность этих контейнеров и представляют среду для работы приложения.
        - Контейнеры также видят сам проект, его данные.
    
    - После запуска можно взаимодействовать с проектом, например, открыть в браузере.
    
  # Что делает CLI-команда up при запуске приложения
  
    • Встраивает алиасы для работы с приложением в текущий шелл
      - Выполняя <проект>/other/cli/aliases с помощью source.
  
    • Копирует конфиги из выбранной группы в каталог /configs/active
      - И docker-среда запустится с применением этих скопированных конфигов.
      - По умолчанию, конфиги копируются из группы dev.
      - Но с помощью опции -c можно указать другую группу конфигов.

    • Выполняет всякие доп.проверки и валидации
    
    • Выполняет запуск приложения командой docker-compose up -d
      - Эта команда, если надо, скачивает необходимые образы с Docker Hub.
      - И выполняет запуск и настройку всех описанных в docker-compose.yml контейнеров.

EOF
fi

# 4. Если help вызван с 1-ым аргументом down, показать справку по этой команде
if [ $# != 0 ] && [ $1 == "down" ]; then 

  # Показать краткую справку по команде install
  echo  " "  
  echo  "NAME"
  echo  "     down - остановить проект с помощью docker-compose"
  echo  " "
  echo  "SYNOPSIS"
  echo  "     . app down"
  echo  " "  
  echo  "OPTIONS"
  echo  "     -h - показать справку по команде"  
  echo  " "

EOF
fi

# 5. Если help вызван с 1-ым аргументом update, показать справку по этой команде
if [ $# != 0 ] && [ $1 == "update" ]; then 

  # Показать краткую справку по команде install
  echo  " "  
  echo  "NAME"
  echo  "     update - обновить среду и файлы проекта с репчика на GitHub"
  echo  " "
  echo  "SYNOPSIS"
  echo  "     . app update"
  echo  " "  
  echo  "OPTIONS"
  echo  "     -h - показать справку по команде"  
  echo  "     -n - не запускать проект после обновления"  
  echo  "     -c <name> - имя группы конфигов, с которыми запускать приложение (dev по умол.)"  
  echo  " "
  echo  "DESCTIPTION"
  cat <<'EOF'

  # Что обновляет команда update
  
    • Используемые приложением docker-образы
      - Для их обновления приложение удаляет старые образы.
      - И скачивает новые с Docker Hub.
      
    • Сами файлы приложения
      - Кроме некоторых, которые не следует обновлять (см.ниже).

  # Обновление приложения производится данными из репчика на GitHub
    
    • У каждого проекта должен быть свой репчик на GitHub
      - Команда update скачивает из этого репчика обновлённый проект.
      - И заменяет старые файлы на новые.
    
    • Адрес репчика проекта на GitHub указан в конфиге проекта
    - Сабж.
    
    • Что не обновляется при обновлении приложения
      - Всё, что не обновляется, не присутствует в репчике проекта.
      - Поскольку всё это присутствует в файле .gitignore.
      - Следующие каталоги и файлы не присутствуют в репчике:

        ▪ /<папка проекта>/data
        ▪ /<папка проекта>/other/cli/config
        ▪ /<папка проекта>/other/logs
    
  # Что делает CLI-команда update при обновлении приложения
    
    • Считывает URL репчика проекта из конфига, проверяет его наличие
    
    • Останавливает приложение с помощью docker-compose down
    
    • Удаляет все связанные с приложением docker-образы, скачивает новые
    
    • Скачивает содержимое репчика, заменяет им текущее содержимое проекта
    
    • Запускает проект с помощью команды . app up
      - Но только если не передана опция -n.
      - И если передана команда -c, передав команде up её тоже.  

EOF
fi

